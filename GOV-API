program pnw_government_api.aleo;

// Import cryptographic tools
use std::crypto::pedersen_commit;
use std::collections::map;

// **ðŸ”¹ Government API Request Structure**
struct GovernmentAPIRequest {
    government_id: field,  // Unique identifier for government entity
    worker_id: u32,  
    request_type: field,  // "VisaCheck" or "WorkVerification"
}

// **ðŸ”¹ Worker NFT Structure**
struct WorkerNFT {
    worker_id: u32,
    owner: address,
    visa_status: field,  // Temporary, Permanent, etc.
    visa_expiry: u64,  // Expiration timestamp
    total_earnings: u64,  
    trust_fund_balance: u64,  
}

// **ðŸ”¹ Declare Mappings**
mapping worker_nfts: map<address, WorkerNFT>;
mapping government_requests: map<u32, GovernmentAPIRequest>;
mapping approved_governments: map<field, bool>; // Stores approved agencies

// **ðŸ”¹ Approve Government Agencies for API Access**
transition approve_government_agency(government_id: field) -> bool {
    approved_governments[government_id] = true;
    return true;
}

// **ðŸ”¹ Government Requests Worker Verification**
transition request_worker_verification(government_id: field, worker_id: u32, request_type: field) -> bool {
    assert(approved_governments[government_id], "Unauthorized government request");

    let request = GovernmentAPIRequest { government_id, worker_id, request_type };
    government_requests[worker_id] = request;
    
    return true;
}

// **ðŸ”¹ Verify Worker NFT (For Governments & Employers)**
function verify_worker_nft(worker_id: u32) -> WorkerNFT {
    let nft = worker_nfts.iter().find(|(_, n)| n.worker_id == worker_id);
    assert(nft.is_some(), "Worker NFT not found");

    return nft.unwrap().1;
}
